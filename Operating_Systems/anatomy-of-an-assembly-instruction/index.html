<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  lang="en" data-theme="dark">
<head>
	<!-- 2025-04-14 Mon 14:53 -->
	<meta charset="UTF-8" />
	<meta name="description" content="" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<meta name="theme-color" content="#9ac2c2" />
	<title>404 - Gio's site</title>
	<link rel="canonical" href="https://giogiobestcat.github.io/Operating_Systems/anatomy-of-an-assembly-instruction/" /><link rel="icon" type="image/png" href="https://giogiobestcat.github.io/favicon.png" />

<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="https://giogiobestcat.github.io/apple-touch-icon.png" />
<style type="text/css">
	:root {--accent-color: #9ac2c2;}</style>

			<link type="text/css" rel="stylesheet" href="https://giogiobestcat.github.io/style.css" />
			<script type="text/javascript" defer  src="https://giogiobestcat.github.io/closable.js"></script>

	<meta property="og:site_name" content="Gio&#x27;s site" />
	<meta property="og:title" content="404 - Gio's site" />
	<meta property="og:url" content="https://giogiobestcat.github.io/Operating_Systems/anatomy-of-an-assembly-instruction/" />
	<meta property="og:description" content="" /><meta property="og:image" content="https://giogiobestcat.github.io/card.png" /><meta property="og:locale" content="en_US" />
</head>

<body>
<main id="main-content">
		
<h1></h1><p>Recall that an assembly instruction is simply a fixed-size series of bits.
The length of an instruction varies and depends on how complicated an
instruction is. What every instruction shares is a common format described
in the figure above that divides the bits of an instruction into smaller
parts that encode different types of information.</p>
<p>![[Pasted image 20240627174501.png]]</p>
<ul>
<li>
<p>An instruction prefix is an optional prefix to an instruction that makes it behave a bit differently. For example:</p>
<ul>
<li><code> add eax, ecx</code> -&gt; 66  01 C8 -&gt; 66 is a prefix</li>
<li>The 0x66 prefix limits the operand sizes to 16 bits when in 32 bit mode. The opposite happens when the CPU is in 16 bit mode.</li>
</ul>
</li>
<li>
<p>MODR/M is the register or memory address to be used as an operand</p>
<ul>
<li>mod field, or modifier field, is combined with r/m field for a total of 5 bits of information to encode 32 possible values: 8 registers and 24 addressing modes.</li>
<li>reg/opcode field encodes either a register operand, or extends the Opcode field with 3 more bits.</li>
<li>there are a lot of possible ModR/M values...
![[Pasted image 20240627175121.png]]
<ul>
<li>TO READ THIS TABLE
<ul>
<li>look at the byte value next to the Opcode to know what the corresponding operands are</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>![[Pasted image 20240627175656.png]]</p>
<ul>
<li>Effective address = 1 ∗ (12 ∗ n) + base</li>
<li>Base is the starting address</li>
<li>We can observe the same thing, in C, when dereferencing a pointer. E.g.</li>
</ul>
<pre data-lang="C" style="background-color:#2b303b;color:#c0c5ce;" class="language-C "><code class="language-C" data-lang="C"></code></pre>
</li>
</ul>
<p>int num[4]= {1,2,3,4}) ;
num[1] -&gt; <em>(num+1</em>elementsize)
```</p>
<ul>
<li>![[Pasted image 20240627180329.png]]</li>
</ul>


		

	</main>
	<footer id="site-footer">
</footer>


</body>
</html>
