<!doctype html><html data-theme=dark lang=en xmlns=http://www.w3.org/1999/xhtml><head><meta charset=UTF-8><meta name=description><meta content="width=device-width,initial-scale=1" name=viewport><meta content=#9ac2c2 name=theme-color><title>404 - Gio's site</title><link href=https://giogiowastaken.github.io/Below_Software/cpu-operating-modes/ rel=canonical><link href=https://giogiowastaken.github.io/favicon.png rel=icon type=image/png><link href=https://giogiowastaken.github.io/apple-touch-icon.png rel=apple-touch-icon sizes=180x180 type=image/png><style>:root{--accent-color:#9ac2c2}</style><link href=https://giogiowastaken.github.io/style.css rel=stylesheet><script defer src=https://giogiowastaken.github.io/closable.js></script><meta content="Gio's site" property=og:site_name><meta content="404 - Gio's site" property=og:title><meta content=https://giogiowastaken.github.io/Below_Software/cpu-operating-modes/ property=og:url><meta property=og:description><meta content=https://giogiowastaken.github.io/card.png property=og:image><meta content=en_US property=og:locale><body><main id=main-content><h1></h1><h2 id=overview>Overview</h2><p>The <code>CPU operating modes</code>, or <code>CPU execution mdoes</code> dictate how the <code>CPU</code> accesses memory, handles instructions, and interacts with other system components.<h3 id=real-mode>Real mode</h3><ul><li>The initial operating mode of x86 CPUs, dating back to the original Intel 8086 processor.<li>It is characterized by: <ul><li>20-bit addressing, allowing access to 1 MB of memory.<li>No memory protection or multitasking.<li>Direct access to hardware and peripherals.<li>It does not support virtual memory Since old registers were 16 bits, the theoretical amount of memory that could be accessesed was smaller than the actual amount of memory that was available. To resolve this we used <code>segmentation</code> which allows more efficient use of memory. The formula for <code>segmentation</code> goes as following:</ul></ul><p>Physical address = 16 * segmentat_selector + offset<pre style=color:#c0c5ce;background-color:#2b303b><code><span>hex((0x2000 << 4) + 0x0010)
</span><span>'0x20010' 
</span></code></pre><p><em>NOTE</em>: shifting 4 bits to the left (<<) is akin to multipling by 16, since we are shifting in base 2.<p><strong>Use Case</strong>: BIOS initialization, DOS-based systems, and early boot stages of modern operating systems. Some kernel code is written in <code>real</code> mode, before the kernel moves to protected mode.<h3 id=system-management-mode>System Management Mode:</h3><ul><li>The most privilged mode. Its memory is protected even from the OS. Its job is to do stuff almost exclusively on hardware. E.g. Power management.</ul><h3 id=protected-mode>Protected mode</h3><p><em>NOTE</em> : <code>virtual-8086</code> mode isn't actually a mode. It's an attribute that can be enabled from within protected mode. It allows running <code>Real Mode</code> inside <code>protected mode</code>, for backwards comptability with older programs.<p>Characterized by:<ul><li>32-bit addressing, allowing access to 4 GB of memory (and up to 64 GB with PAE).<li>Memory protection, enabling isolation of processes to prevent them from interfering with each other.<li>Supports multitasking and advanced features like virtual memory.</ul><p>Read more at: [[Protected_Mode]]<h3 id=unreal-mode>Unreal mode</h3><p><strong>Use Case:</strong> Modern operating systems, applications that require memory protection and multitasking.</main><footer id=site-footer></footer>