<!doctype html><html data-theme=dark lang=en xmlns=http://www.w3.org/1999/xhtml><head><meta charset=UTF-8><meta name=description><meta content="width=device-width,initial-scale=1" name=viewport><meta content=#9ac2c2 name=theme-color><title>404 - Gio's site</title><link href=https://giogiowastaken.github.io/Cybersecurity/assembly-and-re/ rel=canonical><link href=https://giogiowastaken.github.io/favicon.png rel=icon type=image/png><link href=https://giogiowastaken.github.io/apple-touch-icon.png rel=apple-touch-icon sizes=180x180 type=image/png><style>:root{--accent-color:#9ac2c2}</style><link href=https://giogiowastaken.github.io/style.css rel=stylesheet><script defer src=https://giogiowastaken.github.io/closable.js></script><meta content="Gio's site" property=og:site_name><meta content="404 - Gio's site" property=og:title><meta content=https://giogiowastaken.github.io/Cybersecurity/assembly-and-re/ property=og:url><meta property=og:description><meta content=https://giogiowastaken.github.io/card.png property=og:image><meta content=en_US property=og:locale><body><main id=main-content><h1></h1><h1 id=useful-interfaces-to-assembly>useful interfaces to assembly</h1><ul><li><p>Debug using GDB-Peda</p> <ul><li><a href=https://github.com/nnamon/linux-exploitation-course/blob/master/lessons/3_intro_to_tools/lessonplan.md>Short Cheatsheet</a></ul><li><p>Use Ghidra</p> <ul><li><a href=https://guyinatuxedo.github.io/02-intro_tooling/ghidra/index.html>Ghidra start</a></ul><li><p>To write assembly comfortambly, use neovim with an LSP server.</p></ul><h1 id=some-referesher-on-assembly>Some referesher on assembly:</h1><ul><li>The registers EAX, EBX, ECX, EDX, ESI, EDI, EBP, and ESP can all be used as operands, while the EIP register cannot.<li>The int instruction (which stands for interrupt) sends an interrupt signal to the system. Interrupts are used to handle events like system calls, hardware signals, or exceptions. Two common interrupt signals are: <ul><li>int 0x80, which sends a syscall interrupt in linux<li>int 0x21, which is used for DOS interrupts. This is no longer used in modern windows systems, which use the <code>windows-api</code> instead.<li>when the OS executes a syscall, it checks <code>EAX</code> for the syscall number, and <code>EBX, ECX, EDX</code> to hold the first, second, and third arguments respectively.</ul></ul><h1 id=basic-assembly>basic assembly:</h1><pre class=language-asm data-lang=asm style=color:#c0c5ce;background-color:#2b303b><code class=language-asm data-lang=asm><span>
</span><span style=color:#65737e>; Example of using int 0x80 for a system call
</span><span style=color:#96b5b4>section </span><span style=color:#8fa1b3>.data
</span><span style=color:#8fa1b3>msg </span><span style=color:#96b5b4>db </span><span style=color:#a3be8c>'Hello, world!'</span><span>, </span><span style=color:#d08770>0xA</span><span style=color:#65737e>  ; Message to print with newline
</span><span>
</span><span style=color:#96b5b4>section </span><span style=color:#8fa1b3>.text
</span><span style=color:#96b5b4>global </span><span style=color:#8fa1b3>_start
</span><span>
</span><span style=color:#8fa1b3>_start:
</span><span style=color:#65737e>    ; Write system call
</span><span style=color:#8fa1b3>    </span><span style=color:#b48ead>mov </span><span style=color:#bf616a>eax</span><span>, </span><span style=color:#d08770>4</span><span style=color:#65737e>          ; sys_write system call number
</span><span style=color:#8fa1b3>    </span><span style=color:#b48ead>mov </span><span style=color:#bf616a>ebx</span><span>, </span><span style=color:#d08770>1</span><span style=color:#65737e>          ; File descriptor 1 (stdout)
</span><span style=color:#8fa1b3>    </span><span style=color:#b48ead>mov </span><span style=color:#bf616a>ecx</span><span>, </span><span style=color:#8fa1b3>msg</span><span style=color:#65737e>        ; Pointer to the message
</span><span style=color:#8fa1b3>    </span><span style=color:#b48ead>mov </span><span style=color:#bf616a>edx</span><span>, </span><span style=color:#d08770>14</span><span style=color:#65737e>         ; Length of the message + 0xA
</span><span style=color:#8fa1b3>    </span><span style=color:#b48ead>int </span><span style=color:#d08770>0x80</span><span style=color:#65737e>            ; Invoke the system call
</span><span>
</span><span style=color:#65737e>    ; Exit system call
</span><span style=color:#8fa1b3>    </span><span style=color:#b48ead>mov </span><span style=color:#bf616a>eax</span><span>, </span><span style=color:#d08770>1</span><span style=color:#65737e>          ; sys_exit system call number
</span><span style=color:#8fa1b3>    </span><span style=color:#b48ead>xor </span><span style=color:#bf616a>ebx</span><span>, </span><span style=color:#bf616a>ebx</span><span style=color:#65737e>        ; Exit code 0
</span><span style=color:#8fa1b3>    </span><span style=color:#b48ead>int </span><span style=color:#d08770>0x80</span><span style=color:#65737e>            ; Invoke the system call
</span></code></pre><h1 id=register-variations>Register variations</h1><p>The EAX, EBX, ECX, EDX, ESI, EDI, EBP, and ESP registers are 32 bits in width.<p>The E stands for extended, because these were originally 16-bit registers called AX, BX, CX, DX, SI, DI, BP, and SP.<p>These original 16-bit versions of the registers can still be used for accessing the first 16 bits of each corresponding 32-bit register.<p>Furthermore, the individual bytes of the AX, BX, CX, and DX registers can be accessed as 8-bit registers called AL, AH, BL, BH, CL, CH, DL, and DH, where L stands for low byte and H for high byte.<p>A lower, A higher B lower, B higher... etc. The registers, at the start, were just , then, register A, B, C ....<p>Naturally, assembly instructions using the smaller registers only need to specify operands up to the registerâ€™s bit width. The three variations of a mov instruction are shown below.<p>![[Pasted image 20240611120537.png]] Using the AL, BL, CL, or DL register will put the correct least significant byte into the corresponding extended register without creating any null bytes in the machine code. This makes them ideal for shellcode writing.<h1 id=c-code-as-it-is-seen-in-assembly>C Code as it is seen in assembly</h1><ul><li>X86_64 parameter call convention is as follows:</ul><table><thead><tr><th>Register<th>Argument<tbody><tr><td>1. <code>RDI</code><td>First argument<tr><td>2. <code>RSI</code><td>Second argument<tr><td>3. <code>RDX</code><td>Third argument<tr><td>4. <code>RCX</code><td>Fourth argument<tr><td>5. <code>R8</code><td>Fifth argument<tr><td>6. <code>R9</code><td>Sixth argument</table><ul><li><p>GDB has an option to deobscuify CPP function names. Use it.</p><li><p>Since function arguments are also passed on the stack, there needs to be space for any that this function wants to pass to another. So while a function might only need x amount of bytes for local variables, $esp is often decremented by a bigger bytesize so that there is space for function arguments.</p><li></ul><h2 id=distinguishing-signed-and-unsigned-comparisons>Distinguishing Signed and Unsigned Comparisons</h2><p>After cmp, the processor uses different conditional jump instructions to handle signed and unsigned comparisons:<p>Unsigned Conditional Jumps: <code>ja (jump above): For > in unsigned terms. jae (jump above or equal): For >= in unsigned terms. jb (jump below): For < in unsigned terms. jbe (jump below or equal): For <= in unsigned terms.</code><p>Signed Conditional Jumps: <code>jg (jump greater): For > in signed terms. jge (jump greater or equal): For >= in signed terms. jl (jump less): For < in signed terms. jle (jump less or equal): For <= in signed terms.</code><h4 id=c-code-example>C Code example</h4><pre class=language-c data-lang=c style=color:#c0c5ce;background-color:#2b303b><code class=language-c data-lang=c><span style=color:#b48ead>if </span><span>(x > </span><span style=color:#d08770>500</span><span>) {
</span><span>    </span><span style=color:#65737e>// Do something
</span><span>}```
</span><span>will turn into: 
</span><span>`
</span><span>cmp x, </span><span style=color:#d08770>500       </span><span>; Compare x with </span><span style=color:#d08770>500
</span><span>jg signed_jump   ; Jump </span><span style=color:#b48ead>if</span><span> x > </span><span style=color:#d08770>500 </span><span>(interpreted as </span><span style=color:#b48ead>signed</span><span>)
</span><span>`
</span><span>
</span><span>```C
</span><span>
</span><span style=color:#b48ead>if </span><span>((</span><span style=color:#b48ead>unsigned</span><span>)x > </span><span style=color:#d08770>500</span><span>) {
</span><span>    </span><span style=color:#65737e>// Do something
</span><span>}
</span><span>
</span></code></pre><p>will turn into: <code>cmp x, 500       ; Compare x with 500 ja unsigned_jump ; Jump if x > 500 (interpreted as unsigned)</code><h1 id=more-assembly-instructions>More assembly instructions</h1><ul><li><p><code>sete</code>, <code>setl</code>, <code>setge</code>, all check the result of the previous <code>cmp</code> operation, stored in the CPU flags, and respectively store the result in the operand passed to it(set equal, set less, set greater equal )</p><li><p><code>shl</code> and <code>shr</code> are used to shift bits left and right.</p><li><p><code>movzx</code> is a <code>mov</code> instruction that also pads the remaining bytes with zeros.</p><li><p>[[Writing_Shellcode]]</p></ul><h1 id=possible-reasons-for-segfaults>Possible reasons for segfaults:</h1><ul><li><p>Read more about data alignment and its role <a href=https://giogiowastaken.github.io/Cybersecurity/assembly-and-re/Data_alignment>here</a>.</p><li><p>In assembly, the OS expects some values, depending on their size, to be aligned in some specific manner. 4 byte values must end in a hex digit that's divisible by 4, and the same goes for 8 byte values such as ESP. More info about stack alignment right below.</p> <ul><li>This can be beaten by chaining a return addresses into the payload, before the target address, thus moving ESP to a location so that it's properly aligned and a segfault doesn't occur.</ul><li><p>Remember that not only stack allignment matters, but also ESP. In some instances, your shellcode has potential to move ESP to a location such that it overwrites itself on the stack.</p></ul><p><a href=https://gist.github.com/DtxdF/9c9297945bd7165c53b264ec597a9c39>Reverse engineering Resource list</a></main><footer id=site-footer></footer>