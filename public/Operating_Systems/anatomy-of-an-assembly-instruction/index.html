<!doctype html><html data-theme=dark lang=en xmlns=http://www.w3.org/1999/xhtml><head><meta charset=UTF-8><meta name=description><meta content="width=device-width,initial-scale=1" name=viewport><meta content=#9ac2c2 name=theme-color><title>404 - Gio's site</title><link href=https://giogiowastaken.github.io/Operating_Systems/anatomy-of-an-assembly-instruction/ rel=canonical><link href=https://giogiowastaken.github.io/favicon.png rel=icon type=image/png><link href=https://giogiowastaken.github.io/apple-touch-icon.png rel=apple-touch-icon sizes=180x180 type=image/png><style>:root{--accent-color:#9ac2c2}</style><link href=https://giogiowastaken.github.io/style.css rel=stylesheet><script defer src=https://giogiowastaken.github.io/closable.js></script><meta content="Gio's site" property=og:site_name><meta content="404 - Gio's site" property=og:title><meta content=https://giogiowastaken.github.io/Operating_Systems/anatomy-of-an-assembly-instruction/ property=og:url><meta property=og:description><meta content=https://giogiowastaken.github.io/card.png property=og:image><meta content=en_US property=og:locale><body><main id=main-content><h1></h1><p>Recall that an assembly instruction is simply a fixed-size series of bits. The length of an instruction varies and depends on how complicated an instruction is. What every instruction shares is a common format described in the figure above that divides the bits of an instruction into smaller parts that encode different types of information.<p>![[Pasted image 20240627174501.png]]<ul><li><p>An instruction prefix is an optional prefix to an instruction that makes it behave a bit differently. For example:</p> <ul><li><code> add eax, ecx</code> -> 66 01 C8 -> 66 is a prefix<li>The 0x66 prefix limits the operand sizes to 16 bits when in 32 bit mode. The opposite happens when the CPU is in 16 bit mode.</ul><li><p>MODR/M is the register or memory address to be used as an operand</p> <ul><li>mod field, or modifier field, is combined with r/m field for a total of 5 bits of information to encode 32 possible values: 8 registers and 24 addressing modes.<li>reg/opcode field encodes either a register operand, or extends the Opcode field with 3 more bits.<li>there are a lot of possible ModR/M values... ![[Pasted image 20240627175121.png]] <ul><li>TO READ THIS TABLE <ul><li>look at the byte value next to the Opcode to know what the corresponding operands are</ul></ul></ul><li><p>![[Pasted image 20240627175656.png]]</p> <ul><li>Effective address = 1 ∗ (12 ∗ n) + base<li>Base is the starting address<li>We can observe the same thing, in C, when dereferencing a pointer. E.g.</ul> <pre class=language-C data-lang=C style=color:#c0c5ce;background-color:#2b303b><code class=language-C data-lang=C></code></pre></ul><p>int num[4]= {1,2,3,4}) ; num[1] -> <em>(num+1</em>elementsize) ```<ul><li>![[Pasted image 20240627180329.png]]</ul></main><footer id=site-footer></footer>