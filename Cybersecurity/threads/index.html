<!doctype html><html data-theme=dark lang=en xmlns=http://www.w3.org/1999/xhtml><head><meta charset=UTF-8><meta name=description><meta content="width=device-width,initial-scale=1" name=viewport><meta content=#9ac2c2 name=theme-color><title>Threads - Gio's site</title><link href=https://giogiowastaken.github.io/Cybersecurity/threads/ rel=canonical><link href=https://giogiowastaken.github.io/favicon.png rel=icon type=image/png><link href=https://giogiowastaken.github.io/apple-touch-icon.png rel=apple-touch-icon sizes=180x180 type=image/png><style>:root{--accent-color:#9ac2c2}</style><link href=https://giogiowastaken.github.io/style.css rel=stylesheet><script defer src=https://giogiowastaken.github.io/closable.js></script><meta content="Gio's site" property=og:site_name><meta content="Threads - Gio's site" property=og:title><meta content=https://giogiowastaken.github.io/Cybersecurity/threads/ property=og:url><meta property=og:description><meta content=https://giogiowastaken.github.io/card.png property=og:image><meta content=en_US property=og:locale><body><main id=main-content><h1>Threads</h1><h1 id=definition>Definition:</h1><p>A thread is the smallest unit of execution within a process. It shares:<ul><li>The process's memory space.<li>Global variables and resources of the process.</ul><h1 id=characteristics>Characteristics:</h1><ul><li>Threads within the same process can communicate more efficiently than processes, as they share memory.<li>Threads allow concurrent execution within a single process, making them lightweight compared to processes.<li>Examples: A browser's tabs might run as threads within the same process (or as separate processes in modern browsers).</ul><h1 id=proccesses-vs-threads>Proccesses vs threads:</h1><p>Threads are considered more lightweight than processes because they share resources within the same process and require less overhead to create, manage, and switch between. Here's a detailed breakdown:<h2 id=shared-resources>Shared Resources</h2><p>Threads: Threads within a process share: The same memory space (heap, global variables). Open file descriptors. Network sockets and other system resources. This eliminates the need to duplicate these resources, reducing memory usage and setup time. Processes: Each process has its own: Separate memory space. Copies of system resources (file descriptors, environment variables). Creating a new process involves duplicating and initializing these resources, which is more resource-intensive.<h2 id=creation-cost>Creation Cost</h2><p>Threads: Creating a thread typically involves: - Allocating a small amount of memory for the thread's stack and control block. - Registering the thread with the operating system.<p>This is relatively fast and lightweight.<p>Processes:<p>Creating a new process involves:<ul><li>Allocating and initializing a full memory space. <ul><li>A full memory space will include some memory for the stack, the <code>.text</code> section, <code>.bss</code> and <code>.data</code> sections, and a kernel context stack for syscalls.</ul><li>Setting up a new process control block (PCB) with details like page tables and scheduling information. Copying resources or setting up shared resources (e.g., fork semantics in Unix-like systems can use copy-on-write but still incurs more cost than thread creation).</ul><h2 id=context-switching>Context Switching</h2><p>Threads:<p>Switching between threads within the same process is faster because:<ul><li>The memory space remains the same.<li>Only the CPU registers, program counter, and stack pointer need to be updated.</ul><p>Processes:<p>Switching between processes requires:<ul><li>Flushing and reloading memory mappings (virtual memory).<li>Switching page tables and possibly invalidating caches.<li>This involves more work for the CPU and operating system.</ul></main><footer id=site-footer></footer>