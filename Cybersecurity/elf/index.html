<!doctype html><html data-theme=dark lang=en xmlns=http://www.w3.org/1999/xhtml><head><meta charset=UTF-8><meta name=description><meta content="width=device-width,initial-scale=1" name=viewport><meta content=#9ac2c2 name=theme-color><title>Elf - Gio's site</title><link href=https://giogiowastaken.github.io/Cybersecurity/elf/ rel=canonical><link href=https://giogiowastaken.github.io/favicon.png rel=icon type=image/png><link href=https://giogiowastaken.github.io/apple-touch-icon.png rel=apple-touch-icon sizes=180x180 type=image/png><style>:root{--accent-color:#9ac2c2}</style><link href=https://giogiowastaken.github.io/style.css rel=stylesheet><script defer src=https://giogiowastaken.github.io/closable.js></script><meta content="Gio's site" property=og:site_name><meta content="Elf - Gio's site" property=og:title><meta content=https://giogiowastaken.github.io/Cybersecurity/elf/ property=og:url><meta property=og:description><meta content=https://giogiowastaken.github.io/card.png property=og:image><meta content=en_US property=og:locale><body><main id=main-content><h1>Elf</h1><h2 id=general-information>General information</h2><ul><li><p>If a binary file were to only consist of <code>data</code> and <code>code</code>, from the perspective of the OS the file is undefined. Which region is code? which region is <code>protected</code>? This is why we have file formats.</p><li><p>When a source file is compiled, the generated machine code is stored in an <code>object file</code>, which is just a block of binary. <code>Object Files</code> can be combined to produce an executable binary, which is a complete binary program runnable in an operating system.</p><li><p>ELF is a common file format for all: <code>executables, object code, shared libraries</code>, and <code>core dumps</code>.</p><li><p>Segments and sections are the main content of an ELF binary, which are the code and data, divided into chunks of different purposes.</p><li><p>A <code>segment</code> is a composition of zero or more <code>sections</code> and is directly loaded by an operating system at runtime.</p><li><p>A section is a block of binary that is either:</p> <ul><li>actual program code and data that is available in memory when a program runs.<li>metadata about other sections used only in the linking process, that disappears from the final executable.</ul><li><p>The linker uses <code>sections</code> to build <code>segments</code>. Object files, are ELFs before the linking stage. They are made of <code>sections</code>.</p></ul><h2 id=elf-header>ELF header</h2><ul><li>All of this information can be viewed by running: <code>readelf -h &LTfilename></code></ul><p>![[Pasted image 20240628190409.png]] To be more easy on the eyes, let's treat it as a struct (which is how it's implemented either way).<ul><li>It starts with a sequence of 4 <code>'magic'</code> bytes. the value <code>0x7f</code> followed by ELF in ascii this lets the OS (or any program that would like to know) that the file is the ELF type.<li>After that, We have the filetype halfword(here a word is defined as 4 bytes)which defines the type of the file. <ul><li><code>0x0001</code> is used for <code>object</code> files.<li><code>0x0002</code> is used for binaries without ASLR.<li><code>0x0003</code> is used for binaries that have ASLR(or PIE) enabled, and shared object files.<li><code>0x004</code> is used for core dumps. ![[Pasted image 20240628191009.png]]</ul><li>the version byte is always 1. ELF has been in version 1 since it's first release!<li>to avoid clobbering this document with barely relevant information, simply refer to <a href=https://www.youtube.com/channel/UC3S8vxwRfqLBdIhgRlDRVzw>this YouTube video </a> for more information.</ul><h2 id=sections-and-the-section-header-table>Sections and the Section Header Table</h2><ul><li>note that sections are largely irrelavent to reverse engineering and debugging , seeing as binaries only use segments</ul><ul><li>we can strip a binary of its sections, and it will work perfectly fine.</ul><p>As we know already, code and data compose a program. However, not all types of code and data have the same purpose. For that reason, instead of a big chunk of code and data, they are divided into smaller chunks(<code>sections</code>), and each section must satisfy the following conditions:<ul><li><p>Every section in an object file has exactly one section header describing it. But, section headers may exist that do not have a section.</p><li><p>Each section occupies one contiguous (possibly empty) sequence of bytes within a file. That means, there’s no two regions of bytes that are the same section.</p><li><p>Sections in a file may not overlap. No byte in a file resides in more than one section.</p><li><p>An object file may have inactive space. The various headers and the sections might not “cover” every byte in an object file. The contents of the inactive data are unspecified.</p></ul><h4 id=relocation>Relocation</h4><ul><li><p><code>Relocation</code> is the process of adjusting addresses within a program so that it can execute correctly when loaded into memory. During compilation, the compiler generates object files with placeholder addresses for functions and variables. The linker combines these object files into an executable or shared library, creating relocation entries for addresses that need adjustment.</p> <ul><li>this is the reason why object file sections address info are not set.</ul><li><p>When the program is loaded into memory, the loader uses these relocation entries to modify addresses so they point to the correct memory locations. This ensures that all references within the program are accurate, allowing it to run correctly. For dynamic linking, mechanisms like the Global Offset Table (GOT) and Procedure Linkage Table (PLT) handle runtime relocation, resolving addresses of global variables and functions in shared libraries. The dynamic linker updates the GOT and PLT entries, enabling the program to access shared library symbols efficiently.</p></ul><h2 id=segments-and-the-program-header-table>Segments and the Program Header Table</h2><ul><li>we can look at segments using <code>readelf --segments &LTfilename></code></ul><p>A program header table is an array of <code>program headers</code> that defines the memory layout of a program at runtime. A <code>program header</code> is a description of a <code>program segment</code>. A <code>program segment</code> is a collection of related sections. A segment contains zero or more sections. OSes only look at segments. ![[Pasted image 20240628195931.png]] We define a <code>segment</code> as an array that contains the following: (I will not be writing about everything, reference video linked above):<ul><li>A type <ul><li>PT_NULL is a placeholder that disables a segment<li>PT_LOAD refers to segments that will be loaded into memory. How they will be loaded is specified in the <code>flags</code> field.<li>PT_DYNAMIC contains information required for dynamically linked binaries.</ul><li>An offset<li>virtual and physical address</ul><h2 id=an-elf-s-sections>An ELF's sections</h2><p>[!note] Note: For an executable program, an ELF header and a segment are the bare minimum, with sections being optional.<p>[!Attention] But even so, it's common for an executable to have a ".text" section for the code and ".data" section for initialized data.<p>Sections can be viewed with <code>objdump &LTbinary> -h</code><ul><li>Libraries don't have segments, but only sections because they are used for linking purposes.</ul><p>A compiled program’s memory is (mainly) divided into five sections: <code>text</code>, <code>data</code>, <code>bss</code>, <code>heap</code>, and <code>stack</code>. Each segment represents a special portion of memory that is set aside for a certain purpose.<ul><li><p><strong>Note:</strong> there's also <code>.rodata</code> which is for read-only data.</p><li><p>the <code>text</code> also referred to as the <code>code segment</code> stores the assembly instructions executed by the binary. Execution is obviously not linear, with jumps and branches utilized constantly.</p> <ul><li>as an ELF binary executes the <code>text</code> segment, the following loop is iterated through: <ol><li>Reads the instruction that EIP is pointing to<li>Adds the byte length of the instruction to EIP. See [[ARM assembly]] for more info about its eccentricities.<li>Executes the instruction that was read in step 1<li>Goes back to step 1</ol><li>the <code>text</code> segment is not writable. Attempts to write to it would result in a segfault and warning. Since it's not writable, it has a fixed size.</ul><li><p>the <code>data</code> and <code>bss</code> sections are used to store <code>global</code> and <code>static</code> variables(each one stores both. See the below).</p> <ul><li><code>static variables</code> are variables that are only initialized once, and their value is retained through subsequent functions calls. They exist, of course, only inside the scope of the function that calls them.<li><code>data</code> has initialized globals, while <code>bss</code> has uninitiliazed globals (globals that are not initiliazed with any data.)<li>this is why global and static variables persist throughout the lifetime of the program -- they have their own memory sections.<li>the <code>data</code> and <code>bss</code> sections, also have a fixed size. <code>If it has a fixed size, it can be overflowed.</code></ul><li><p>You are already very familiar with <code>The Heap</code> and <code>The Stack</code> so there is no need to mention them.</p><li><p>Finally, one can assume what happens when <code>The Heap</code> and <code>The Stack</code> meet! ![[Pasted image 20240607151555.png]]</p></ul><p>Helpful information curated: <a href=https://gist.github.com/DtxdF/e6d940271e0efca7e0e2977723aec360>ELF binary cheatsheet</a><h3 id=readelf-output>ReadELF output:</h3><p><code>readelf -l &LTbinary></code> E.X:<p><code>LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000 0x000000000000073c 0x000000000000073c  R E    0x200000</code><ul><li><p>Interpretation:</p> <ul><li><p>file Offset (0x0000000000000000):</p> <ul><li>This tells you where in the file this segment begins. In this case, it starts at offset 0 in the ELF file, meaning it's the first segment loaded into memory.</ul></ul> <ul><li><p>Virtual Address (0x0000000000400000):</p> <ul><li>This is where the segment is loaded into memory. Here, it starts at the virtual address 0x400000. This is the memory address where the executable (or the program) will place this segment.</ul><li><p>Physical Address (0x0000000000400000):</p> <p>*This field is generally used by systems with physical memory addressing (like embedded systems). In most user-level ELF files on modern systems (like Linux on x86-64), this field is not used and mirrors the virtual address (0x400000).</p><li><p>File Size (<code>FileSiz</code> = 0x000000000000073c):</p> <ul><li>This is the size of the segment on disk. The value 0x73c means 1,860 bytes are present in the file. Typically, this segment contains the code section (.text), which is why it's marked R E (Read, Execute). It means this part of the binary contains executable code.</ul><li><p>Memory Size (<code>MemSiz</code> = 0x000000000000073c):</p> <p>*This is the size of the segment in memory. In this case, MemSiz matches FileSiz (0x73c), which means the entire segment is loaded into memory, with no additional space required. This is typical for the code section, which doesn't need extra memory for uninitialized data.</p><li><p>And lastly, <code>Align</code> (0x200000).</p></ul></ul><pre style=color:#c0c5ce;background-color:#2b303b><code><span>
</span><span>readelf -lW lnstat (W for wide, better output)
</span><span>
</span><span>Elf file type is DYN (Position-Independent Executable file)
</span><span>Entry point 0x1c00
</span><span>There are 9 program headers, starting at offset 64
</span><span>
</span><span>Program Headers:
</span><span>Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align
</span><span>PHDR           0x000040 0x0000000000000040 0x0000000000000040 0x0001f8 0x0001f8 R   0x8
</span><span>INTERP         0x000238 0x0000000000000238 0x0000000000000238 0x00001b 0x00001b R   0x1
</span><span>[Requesting program interpreter: /lib/ld-linux-aarch64.so.1]
</span><span>LOAD           0x000000 0x0000000000000000 0x0000000000000000 0x003f7c 0x003f7c R E 0x10000
</span><span>LOAD           0x00fc48 0x000000000001fc48 0x000000000001fc48 0x000528 0x001190 RW  0x10000
</span><span>DYNAMIC        0x00fc58 0x000000000001fc58 0x000000000001fc58 0x000200 0x000200 RW  0x8
</span><span>NOTE           0x000254 0x0000000000000254 0x0000000000000254 0x0000e0 0x0000e0 R   0x4
</span><span>GNU_EH_FRAME   0x003610 0x0000000000003610 0x0000000000003610 0x0001b4 0x0001b4 R   0x4
</span><span>GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x10
</span><span>GNU_RELRO      0x00fc48 0x000000000001fc48 0x000000000001fc48 0x0003b8 0x0003b8 R   0x1
</span><span>
</span><span> Section to Segment mapping:
</span><span> Segment Sections...
</span><span> 00     
</span><span> 01     .interp 
</span><span> 02     .interp .note.gnu.build-id .note.ABI-tag .note.package .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame 
</span><span> 03     .init_array .fini_array .dynamic .got .data .bss 
</span><span> 04     .dynamic 
</span><span> 05     .note.gnu.build-id .note.ABI-tag .note.package 
</span><span> 06     .eh_frame_hdr 
</span><span> 07     
</span><span> 08     .init_array .fini_array .dynamic .got 
</span><span>
</span></code></pre><p>The above program has 9 program headers, then, the segment mapping indicates in which program header (from 00 to 08) each section is located.<p>PHDR = 00 Dynamic = 05, etc.<h3 id=an-elf-s-segments>An ELF's Segments:</h3><h4 id=phdr>PHDR:</h4><p>Program HeaDeR, for its metadata and the header tables.<h4 id=intrp>INTRP</h4><p>Indicates the path of the loader to use to load the binary into memory.<h4 id=load>LOAD</h4><p>These headers are used to indicate how to load a binary into memory. Each LOAD header indicates a region of memory (size, permissions and alignment) and indicates the bytes of the ELF binary to copy in there.<p>Breakdown example:<p>the second one has a size of 0x1190, should be located at 0x1fc48 with permissions read and write and will be filled with 0x528 from the offset 0xfc48 (it doesn't fill all the reserved space). This memory will contain the sections : <code>.init_array .fini_array .dynamic .got .data .bss</code><h4 id=dynamic>Dynamic</h4><p>This header helps to link programs to their library dependencies and apply relocations. Check the <code>.dynamic</code> section, which is the only section mapped to the segment.<p>More info found <a href=https://book.hacktricks.xyz/binary-exploitation/basic-stack-binary-exploitation-methodology/elf-tricks>here</a>.<h4 id=misc>Misc:</h4><ul><li>The BSS section immediately follows the .data section in memory.<li>The memory range for .bss starts after .data and occupies the extra space defined by MemSiz - FileSiz</ul></main><footer id=site-footer></footer>