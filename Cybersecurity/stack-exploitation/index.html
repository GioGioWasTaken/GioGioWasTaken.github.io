<!doctype html><html data-theme=dark lang=en xmlns=http://www.w3.org/1999/xhtml><head><meta charset=UTF-8><meta name=description><meta content="width=device-width,initial-scale=1" name=viewport><meta content=#9ac2c2 name=theme-color><title>Stack Exploitation - Gio's site</title><link href=https://giogiowastaken.github.io/Cybersecurity/stack-exploitation/ rel=canonical><link href=https://giogiowastaken.github.io/favicon.png rel=icon type=image/png><link href=https://giogiowastaken.github.io/apple-touch-icon.png rel=apple-touch-icon sizes=180x180 type=image/png><style>:root{--accent-color:#9ac2c2}</style><link href=https://giogiowastaken.github.io/style.css rel=stylesheet><script defer src=https://giogiowastaken.github.io/closable.js></script><meta content="Gio's site" property=og:site_name><meta content="Stack Exploitation - Gio's site" property=og:title><meta content=https://giogiowastaken.github.io/Cybersecurity/stack-exploitation/ property=og:url><meta property=og:description><meta content=https://giogiowastaken.github.io/card.png property=og:image><meta content=en_US property=og:locale><body><main id=main-content><h1>Stack Exploitation</h1><ul><li>In order to exploit the stack, one must intimately understand [[Assembly and RE]].<li>There are several very commonly used buffer overflow mitigations. Here is a short description of them: <ul><li><a href=https://giogiowastaken.github.io/Cybersecurity/stack-exploitation/NX>NX</a><li><a href=https://giogiowastaken.github.io/Cybersecurity/stack-exploitation/RELRO>RELRO</a><li><a href=https://giogiowastaken.github.io/Cybersecurity/stack-exploitation/ASLR>ASLR</a><li><a href=https://giogiowastaken.github.io/Cybersecurity/stack-exploitation/PIE.md>PIE</a></ul><li>[[ROP]] is a very useful technique to bypass all kinds of data execution preventation mitigations.<li>A perfectly good attack might still end in a segfault due to faulty stack alignment. More at [[Assembly_and_RE]].<li>See [[Stack_facts]]<li>In situations where the buffer isn't large enough to store shellcode, but the stack is still executable, we can store shellcode inside env variables, and locate their offset from ESP, seeing as they are stored on the stack.<li>keep track of all the values you control! <ul><li>if you can write to a value, keep track of every point in the program where that value is used. If it's assigned to another value, this might be an arbitrary write primitive!</ul></ul></main><footer id=site-footer></footer>